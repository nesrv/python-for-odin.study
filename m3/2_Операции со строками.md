# Модуль 2

## 1 Операции со строками

```python
s1 = "Панда" # в двойных кавычках
s2 = 'Panda' # или в одинарных (апострофах):
s2 = Panda # ошибка

text = '''Я Python бы выучил только за то,
что есть популярные курсы.
Много хороших курсов!''' # многострочная строка

a = ""
a = " "
s1 = "Я люблю"
s2 = "язык Python
s3 = s1 + s2
print(s3)

s3 = s1 + " " + s2
s3 = s1 + 5 # ошибка
s3 = s1 + str(5) 

"ха " * 5
"ха " * 5.5

a = "hello"
len(a)
len("") # 0
len("Python")

'ab' in "abracadabra"
'abc' in "abracadabra"

a == "hello" # ==
a == "Hello"
a != "hello"
a != "hello "

'кот' > 'кит'
'кот' > 'кот'
'Кот ' > 'кот'
ord('К')
ord('к')
```

#### Резюме

* `+` (конкатенация) – соединение строк;
* `*` (дублирование) – размножение строкового фрагмента;
* `str()` – функция для преобразования аргумента в строковое представление;
* `len()` – вычисление длины строки;
* `in` – оператор для проверки вхождения подстроки в строку;
* операторы сравнения: ==   !=   >   <
* `ord()` – определение кода символа.


### 2 Форматированный вывод

```python
x = 5.76
y = -8
print("Координаты точки: x = ", x, "; y = ", y)
print(f"Координаты точки: x = {x}; y = {y}")

age=18; name="Александр"
"Меня зовут {0}, мне {1} и я люблю язык Python.".format(name, age)
msg = "Меня зовут {0}, мне {1} и я люблю язык Python.".format(name, age)
"Меня зовут {fio}, мне {old} и я люблю язык Python. {fio}".format(fio=name, old=age)

"Меня зовут {fio}, мне {old} и я люблю язык Python. {fio}".format(old=age, fio=name)
f"Меня зовут {name}, мне {age} и я люблю язык Python."
f"Меня зовут {name.upper()}, мне {age*2} и я люблю язык Python."
f"Меня зовут {len(name)}, мне {14*2} и я люблю язык Python."
template = "%s — главное достоинство программиста. (%s)"
print(template % ("Лень", "Larry Wall"))

```


### 3 Модификаторы f-строк

```python
num = 2 / 3
print(num)
print(f"{num:.3f}") # выводим число с точностью до 3-го знака
0.6666666666666666
0.667
```

### 4 Системы счисления с помощью f-строк


```python
print(f'{10:b}') #двоичная СС
print(f'{10:o}') #8-ричная СС
print(f'{10:x}') #16-ричная СС
print(f'{10:X}') #16-ричная СС
print(f'{10:e}') # научная (экспоненциальный вид)
print(f'{10:E}') # научная (экспоненциальный вид)
print(f'{10.5:f}') # тип float (6-символов после запятой)
print(f'{100:c}') # символ юникода
```

#### Обратный перевод - функция int


> P.S 
* В математике числа обладают естественной иерархией. 
* Например, все натуральные числа являются целыми, а все целые числа — рациональными. 
* Все рациональные числа — это вещественные числа, а все вещественные числа — это комплексные числа.


##  [Практика строки](2_Практика_строки.md)

## Индекс и срезы

```python
s = "hello python"
s[0]
s[1]
len(s) - 1

строка[start:stop)
s[1:3]
s[2:-2]
```

## Изменение строк

```python
s[0] = 'H'
s2 = 'H' + s[1:]

```


* строка – упорядоченный набор символов;
* как выполняется индексация к отдельным символам строки str[index];
* как выделять из строк наборы символов – срезы;
* строка – неизменяемый объект;
* способ модификации (изменения) строк через индексы и срезы.



# Методы строк

```python
x = 0.25
y = -0.25
print("\nOriginal Number: ", x)
print(f'{x:.2%}') # print(f'{x = :.2%}')
print("Formatted Number with percentage: "+"{:.2%}".format(x));
print("Original Number: ", y)
print("Formatted Number with percentage: "+"{:.2%}".format(y));
```


```python
s = "python"
```


```python
объект.метод(аргументы)
s.upper()
s.lower()
s.capitalize()
String.count(sub[, start[, end]])
String.find(sub[, start[, end]])
String.rfind(sub[, start[, end]])
String.index(sub[, start[, end]]) 
# Он работает абсолютно также как find, но с одним отличием: 
# если указанная подстрока sub не находится в строке String, то метод приводит к ошибке

String.replace(old, new, count=-1)
msg.replace("a", 'o', 2)
String.isalpha()
String.isdigit()
String.rjust(width[, fillchar = ‘ ‘])
String.ljust(width[, fillchar = ‘ ‘])
String.split(sep=None, maxsplit=-1)
"Иванов Иван Иванович".split(" ")
digs = "1, 2,3, 4,5,6"
digs.replace(" ", "").split(",")
text = "Это был огромный, в два обхвата дуб, с обломанными ветвями и с обломанной корой"
text_parts = text.partition("дуб")
print(text_parts)
# ('Это был огромный, в два обхвата ', 'дуб', ', с обломанными ветвями и с обломанной корой')
d = digs.replace(" ", "").split(",")
", ".join(d)
fio = "Иванов Иван Иванович"
fio2 = ",".join(fio.split())
```

Вместо списка в метод `join` можно передать простую строку, тогда разделитель будет вставляться между символами этой строки:

```python
word = "hello"
joined_word = "|".join(word)
print(joined_word)      # h|e|l|l|o
```

`String.strip()`

удаляет пробелы и переносы строк в начале и конце строки. Например:
```python
"    hello world         \n".strip()
```

возвращает строку `hello world`
Аналогичные методы:

`String.rtrip() и String.ltrip()`

удаляют пробелы и переносы строк только справа или только слева.
Метод `isalpha()` возвращает `True`, если все символы в строке являются алфавитными. 
Если нет, возвращается `False`.

```python
str.isalnum()

str.isascii()
```
Возврат, `True` если строка пуста или все символы в ней являются `ASCII, False` в противном случае. 
Символы `ASCII` имеют кодовые точки в диапазоне от `U+0000 до U+007F`.


* String.upper()	Возвращает строку с заглавными буквами
* String.lower()	Возвращает строку с малыми буквами
* String.count(sub[, start[, end]])	Определяет число вхождений подстроки в строке
* String.find(sub[, start[, end]])	Возвращает индекс первого найденного вхождения
* String.rfind(sub[, start[, end]])	Возвращает индекс первого найденного вхождения при поиске справа
* String.index(sub[, start[, end]])	Возвращает индекс первого найденного вхождения
* String.replace(old, new, count=-1)	Заменяет подстроку old на new
* String.isalpha()	Определяет: состоит ли строка целиком из буквенных символов
* String.isdigit()	Определяет: состоит ли строка целиком из цифр
* String.rjust(width[, fillchar = ‘ ‘])	Расширяет строку, добавляя символы слева
* String.ljust(width[, fillchar = ‘ ‘])	Расширяет строку, добавляя символы справа
* String.split(sep=None, maxsplit=-1)	Разбивает строку на подстроки
* String.join(список)	Объединяет коллекцию в строку
* String.strip()	Удаляет пробелы и переносы строк справа и слева
* String.rstrip()	Удаляет пробелы и переносы строк справа
* String.ltrip()	Удаляет пробелы и переносы строк слева



```python
info = "Имя: %s \t Возраст: %d" % ("Tom", 35)
print(info)   # Имя: Tom     Возраст: 35
```



##  [Практика строки](2_Практика_строки.md)


P.S.

`splitlines()`

### Методы строк-2

`Метод startswith()`
Метод startswith() возвращает True, если строка начинается с указанного префикса (строки). 

Если нет, возвращается False.

`str.startswith(prefix[, start[, end]])` 

startswith в Python принимает не более трех параметров:

* prefix ‒ строка или кортеж проверяемых строк; 
* start (необязательно) ‒ начальная позиция, в которой должен быть проверен префикс в строке;
* end (необязательно) ‒ конечная позиция, в которой необходимо проверить префикс в строке. 

Метод startswith() возвращает логическое значение: 

* Он возвращает True, если строка начинается с указанного префикса. 
* Он возвращает False, если строка не начинается с указанного префикса. 

Пример 1: Без параметров start и end 

```python
text = "Python is easy to learn." 
result = text.startswith('is easy') # returns False 
print(result)
result = text.startswith('Python is ') # returns True 
print(result)
result = text.startswith('Python is easy to learn.') # returns True
print(result)

text = "programming is easy"
result = text.startswith(('python', 'programming')) # prints True
print(result)
result = text.startswith(('is', 'easy', 'java')) # prints False
print(result) # With start and end parameter # 'is easy' string is checked 
result = text.startswith(('programming', 'easy'), 12, 19) # prints False
print(result)
```


Методы `startswith()` и `endswith()` позволяют удобно проверять, начинается или заканчивается ли строка определенной подстрокой.

Эти методы могут быть полезны при работе с файлами, при парсинге данных или при обработке строк в общем. 
Они просты в использовании и широко используются в Python.


## Кодирование и декодирование строк

Если бы вас спросили, «Чем UTF-8 отличается от Unicode?», вы бы с уверенностью дали чёткий ответ? 

В наши дни интернационализации все разработчики должны это сделать. 

Я думаю, что многие из нас не различают эти понятия должным образом. 

Изучим короткое введение в наборы символов и кодировки.

Итак, сначала было слово! И слово называлось Юникод

![alt text](img/unicode.png)

## Набор символов ASCII



![alt text](img/ascii.png)


import string

all = string.printable

print(all)
print(string.ascii_letters)
print(string.digits)
print(string.punctuation)


Откуда взять русский алфавит в Python
```python
cyrillic_lower = [chr(i) for i in range(1072, 1104)]
print(cyrillic_lower)

# или a = ord('а')
''.join([chr(i) for i in range(a, a + 32)])
# 'абвгдежзийклмнопрстуфхцчшщъыьэюя'
```
![alt text](img/utf-8.png)


## Спецсимволы, экранирование символов, raw-строки

Теперь, когда познакомились со строками и их методами, пришло время узнать, какие специальные символы могут содержать строки в Питоне.
С одним из них мы уже сталкивались – это символ перевода строки:
‘\n’
Я напомню, например, когда задается многострочная строка:
```python
text = """hello
python"""
```
то в ней автоматически добавляет этот символ перевода между строками:
```
'hello\npython'
```

Причем, это один символ, хотя он и выглядит как два символа: обратный слеш и n.

Мы в этом легко можем убедиться, если воспользоваться функцией:

```python
len(text)
```
Получим значения `12 = 5 + 6 + 1` – как раз число символов в двух строках плюс один символ перевода строки.

Мало того, мы можем его явно прописывать в любой строке, формируя многострочный текст, например, так:
```python
t = "panda needs\npython"
и, выводя эту строку с помощью функции:
print(t)
```
увидим две строки.

Все их запоминать совсем не обязательно, на практике используются, в основном:

\n, \\, \’, \", \t

Значительно реже другие варианты.

И, обратите внимание, перед каждым спецсимволом записан символ обратного слеша. 

Это, своего рода, маркер начала спецсимвола.

И если после слеша идет одно из обозначений таблицы, то оно будет восприниматься как некая управляющая последовательность.
Давайте я все это продемонстрирую на примерах.

Добавим в строку символ табуляции:
```python
t = "\tpanda needs\npython"

# Теперь функция print() интерпретирует его, как особый горизонтальный отступ:
print(t)
# Если же мы уберем букву t:
t = "\panda needs\npython"
```

то при печати увидим просто обратный слеш. 

В действительности, здесь сработала последняя строчка таблицы: когда не подходит ни одна последовательность, то просто печатается обратный слеш.
Но здесь нужно быть осторожным. 
Предположим, что мы слово needs хотим заключить в обратные слеши:
```python
t = "panda \needs\ python"
#Однако, при печати:
print(t)
```
первый слеш пропадет, так как он будет восприниматься началом спецпоследовательности символа переноса строки. 

Поэтому, для добавления символа обратного слеша в строку, следует записывать два обратных слеша подряд:
```python
t = "panda \\needs\\ python"
```

Тогда в строке они будут автоматически заменены на один символ слеша и при выводе мы это и видим.

Это называется экранированием, когда мы символы с двойным назначением записываем, добавляя перед ними обратный слеш. 

В данном случае получаем двойной слеш.

Часто такие символы следует прописывать при определении путей к файлам.

Как мы знаем, в ОС Windows маршруты имеют вид:
```python
D:\Python\Projects\folder\tex1.py
```
Здесь фигурируют обратные слеши для разделения каталогов. Чтобы правильно описать такой путь, слеши следует экранировать:
```python
path = "D:\\Python\\Projects\\folder\\tex1.py"
#и при печати:
print(path)
```
видим, что маршрут определен верно. Если бы слеши не были экранированы, то получили бы неверный путь к файлу:
```python
path = "D:\Python\Projects\folder\tex1.py"
```

Вот этот момент следует хорошо запомнить.
Кроме обратного слеша экранировать также следует и кавычки. Например, мы хотим сформировать строку:
```python
s = "Марка вина "Ягодка""
```
Внутри этой строки имеются кавычки. Но эти же самые кавычки определяют начало и конец строки в Python. Поэтому такая запись приведет к синтаксической ошибке. Чтобы все работало корректно, нужно выполнить экранирование кавычек:
```python
s = "Марка вина \"Ягодка\""
```

Или, в данном случае, можно было бы использовать одинарные кавычки для определения строки, а внутри нее записать двойные:
```python
s = 'Марка вина "Ягодка"'
```

Но на практике рекомендуется всегда выполнять экранирование таких символов, чтобы избежать случайных ошибок. Например, в этой строке уже нельзя просто так записать одинарные кавычки:
```python
s = 'Марка вина 'Ягодка''
# Снова получим синтаксическую ошибку, их нужно экранировать:
s = 'Марка вина \'Ягодка\''
```

В завершение этого занятия отмечу, что в Python можно задавать, так называемые, сырые (row) строки. 
Это строки, в которых игнорируются спецпоследовательности и все символы воспринимаются буквально так, как записаны. 

Например, если взять строку с путем к файлу:
```python
path = "D:\\Python\\Projects\\folder\\tex1.py"
# то сейчас, при отображении, мы видим по одному слешу:
print(path)
```
Но, если определить эту же строку, как сырую, добавив букву `r` перед ней:
```python
path = r"D:\\Python\\Projects\\folder\\tex1.py"
#то при печати увидим по два слеша, именно так, как прописали. 
# Поэтому, в таких строках можно убрать спецопределения и записывать строку буквально так, как она должна выглядеть:
path = r"D:\Python\Projects\folder\tex1.py"
```

