# Анонимные функции. Сортировка коллекций по ключу

## 1. lambda

Эта часть занятия будет посвящена, так называемым, анонимным или, их еще называют, lambda функциям. 
Что это за функции и почему их называют анонимными? Сейчас вы все узнаете!
Но для начала вспомним как работает функция map

```python

s = 'Hello Python from Russia'

res = s.split()

print(res)
#Результат
['Hello', 'Python', 'from', 'Russia']
А как получить длины слов
res = list(map(len, s.split()))

print(res)
```

А сейчас?
```python
def my_len2(x):return len(x)

res = list(map(my_len2, s.split()))

# А можно сделать вот так 
my_len1 = lambda string: len(string)
res = list(map(my_len1, s.split()))

# Или даже так
res = list(map(lambda x: len(x), s.split()))

# Что происходит, посмотрим на второй пример:
s = [1, 2, 3, 4, 5]
res = list(map(lambda x: x ** 2, s))

print(res)
```

Результат

> [1, 4, 9, 16, 25]

Похожий результат дает генератор! 

> res2 = [x ** 2 for x in s]

А давайте вынесем нашу ламбаду

> lmd = lambda x: x ** 2

> res1 = list(map(lmd, s))

понятно как работает? Закрепим!
> s = ['Hello', 'Python', 'from', 'Russia']

```python
my_len1 = lambda string: len(string)

def my_len2(x):return len(x)

res1 = list(map(my_len1, s))
res2 = list(map(my_len2, s))

print(res1)
print(res2)
```

> lambda a, b: a + b

В чем особенность такого определения функции? Зачем ее придумали и почему бы не пользоваться обычными функциями? У нее есть одно принципиальное отличие от ранее рассматриваемых нами функций – она может быть записана как элемент любой конструкции языка Python. Например, прямо как элемент списка:

>a = [4, 5, lambda: print("lambda"), 7, 8]

Однако, у таких функций есть одно существенное ограничение – в них можно прописать только одну конструкцию языка Python, то есть, выполнить только одну какую-либо команду. 

Также нельзя объявлять анонимные функции в несколько строк:
```python
lambda a: 
    print(a)
```

Аналогичным образом можно преобразовывать коллекции более сложных объектов:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age 
         
people = [ Person("Tom", 38), Person("Kate", 31), Person("Bob", 42), 
        Person("Alice", 34),  Person("Sam", 25) ]
 
# получаем из Person строку с именем
view = map(lambda p: p.name, people)
  
for person in view:
    print(person)

```
Здесь проекция применяется к списку объектов `Person`. 

Функция преобразование получает каждый объект `Person` и возвращает значение его атрибута `name`. 

То есть полученный в результате список будет содержать набор строк (атрибуты name всех объектов `Person`).

Консольный вывод:

```
Tom
Kate
Bob
Alice
Sam
```



## 2. lambda + key

как можно управлять алгоритмом сортировки с помощью специального параметра key, который имеется у метода sort() и функции sorted().
По умолчанию сортировка коллекции выполняется по значениям ее элементов. Например:

```python
a = [4, 3, -10, 1, 7, 12]
b = sorted(a)
print(b)
```

Но мы можем вместо этих значений указать другие, которые будут использованы для сортировки элементов.

Например, вычислить показатель четности значений. Тогда последовательность будет выстроена по возрастанию этих ключей. В результате увидим сначала четные значения, а потом – нечетные.

Чтобы выполнить такую манипуляцию в функции sorted() прописывается аргумент key и ему присваивается ссылка на функцию, которая будет формировать альтернативное значение элемента, то есть, ключ:

```python
b = sorted(a, key=is_odd)
А саму функцию можно определить, следующим образом:
def is_odd(x):
    return x % 2
```

Здесь аргумент x – это текущее значение элемента коллекции, а то, что она возвращает, становится значением соответствующего ключа. 

То есть, для четных значений будем иметь 0, а для нечетных – 1. После запуска программы видим искомый результат сортировки.

Конечно, для простых функций, обычно, в аргументе key записывают лямбда-функцию. В нашем примере она будет выглядеть, следующим образом:

```python
b = sorted(a, key=lambda x: x % 2)
```
Как видите, все достаточно просто.
Тот же самый аргумент key можно указывать и в методе `sort()` для списка:

```python
a.sort(key=lambda x: x % 2)
```
Он здесь работает абсолютно также, как и в функции `sorted()`.

Предположим, что у нас имеется список городов:
```python
lst = ["Москва", "Тверь", "Смоленск", "Псков", "Рязань"]
```
И требуется их выстроить по длине. Для этого воспользуемся функцией `sorted()` и в аргументе key укажем стандартную функцию `len`:

```python
print( sorted(lst, key=len) )
# получим следующий результат:
['Тверь', 'Псков', 'Москва', 'Рязань', 'Смоленск']
# Или можно сделать сортировку по последнему символу слова:
print( sorted(lst, key=lambda x: x[-1]) )
['Москва', 'Псков', 'Смоленск', 'Тверь', 'Рязань']
# Или только по первому:
print( sorted(lst, key=lambda x: x[0]) )
['Москва', 'Псков', 'Рязань', 'Смоленск', 'Тверь']
И так далее.
```

Аргумент `key` часто используют для сортировки сложных структур данных. 

Допустим, у нас имеется вот такой кортеж, содержащий вложенные кортежи с информацией по книгам:
```python
books = (
    ("Евгений Онегин", "Пушкин А.С.", 200),
    ("Муму", "Тургенев И.С.", 250),
    ("Мастер и Маргарита", "Булгаков М.А.", 500),
    ("Мертвые души", "Гоголь Н.В.", 190)
)
```
И нам нужно его отсортировать по цене (последнее значение). Очевидно, это можно сделать так:
> print( sorted(books, key=lambda x: x[2]) )

На выходе получим отсортированный список:

```python
[('Мертвые души', 'Гоголь Н.В.', 190), ('Евгений Онегин', 'Пушкин А.С.', 200), ('Муму', 'Тургенев И.С.', 250), ('Мастер и Маргарита', 'Булгаков М.А.', 500)]
```


Вот так используется аргумент `key` для управления сортировкой элементов произвольных коллекций данных. 

И теперь вы знаете, как его применять в своих программах.
Рассмотрим еще один пример

На складе лежат мешки различного веса и стоимости. Вес за мешок и стоимость записаны на как натуральные числа с списке. Отсортировать мешки по стоимости за кг, при равной стоимости первыми идут мешки с наименьшим весом

```
S = [
    [47, 470],
    [50, 600],
    [60, 480],
    [45, 540],
    [30, 300]
]
```

```
S0 = [(x[1]/x[0], x[0], x[1])  for x in S]
print(S0)
S0.sort(key=lambda x: (x[0], x[2]))
print(S0)

```

